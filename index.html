<!DOCTYPE html><html lang="en"><head><title>index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="index"><meta name="groc-project-path" content="README.md"><meta name="groc-github-url" content="https://github.com/concentricsky/django-sky-ckeditor"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/concentricsky/django-sky-ckeditor/blob/master/README.md">README.md</a></div></div><div id="document"><div class="segment"><div class="comments"><div class="wrapper"><h1 id="django-ckeditor">django-ckeditor</h1>

<p><code>django-ckeditor</code> makes it easy to use <a href="http://ckeditor.com/">CKEditor</a> with your Django 1.3+ text
fields.</p>

<h2 id="setup">Setup</h2>

<p>Install the package with <a href="http://pip.openplans.org/">pip</a> and <a href="http://git-scm.com/">git</a>:</p>

<pre><code>pip install -e git://github.com/concentricsky/django-sky-ckeditor#egg=django-sky-ckeditor
</code></pre>

<p>Add <code>ckeditor</code> to your <code>INSTALLED_APPS</code>.</p>

<p>Add a <code>CKEDITOR_CONFIGS</code> variable to your <code>settings.py</code> with at least a
<code>default</code> config:</p>

<pre><code>CKEDITOR_CONFIGS = {
    'default': {
        'toolbar': [
            [      'Undo', 'Redo',
              '-', 'Format',
              '-', 'Bold', 'Italic', 'Underline',
              '-', 'Link', 'Unlink', 
              '-', 'BulletedList', 'NumberedList',
            ],
            [      'SpellChecker', 'Scayt',
            ],
            [      'Image',
              '-', 'PasteText','PasteFromWord',
              '-', 'Source',
            ]
        ],
        'width': 655,
        'height': 250,
        'toolbarCanCollapse': False,
        'linkShowTargetTab': False,
        'linkShowAdvancedTab': False,
    }
}
</code></pre>

<p>Collect the static files:</p>

<pre><code>python manage.py collectstatic
</code></pre>

<h2 id="usage">Usage</h2>

<p>To use CKEditor for a particular field in a form, set its widget to an
instance of <code>ckeditor.widgets.CKEditor</code> like this:</p>

<pre><code>from ckeditor.widgets import CKEditor

class SampleForm(forms.Form):
    body = forms.CharField(
        widget=CKEditor()
    )
</code></pre>

<p>As a shortcut you can use a <code>ckeditor.fields.HTMLField</code> instead of
<code>django.db.models.TextField</code> in a model to automatically use the CKEditor
widget, like so:</p>

<pre><code>from django.db import models
from ckeditor.fields import HTMLField

class Sample(models.Model):
    # This will use a normal &lt;textarea&gt; when rendered in a (Model)Form
    plain_body = models.TextField(blank=True, verbose_name='plain version')

    # This will use CKEditor when rendered in a (Model)Form
    html_body = HTMLField(blank=True, verbose_name='HTML version')
</code></pre>

<h2 id="custom-configurations">Custom Configurations</h2>

<p>Sometimes it's nice to be able to configure each CKEditor widget separately.
For example, you may want one field to have all the buttons on the toolbar,
but another field to only show bold/italic/underline buttons.</p>

<p>To do this, add additional configurations to your <code>CKEDITOR_CONFIGS</code> setting
like this:</p>

<pre><code>CKEDITOR_CONFIGS = {
    'default': {
        'toolbar': [
            [      'Undo', 'Redo',
              '-', 'Format',
              '-', 'Bold', 'Italic', 'Underline',
              '-', 'Link', 'Unlink', 
              '-', 'BulletedList', 'NumberedList',
            ],
            [      'SpellChecker', 'Scayt',
            ],
            [      'Image',
              '-', 'PasteText','PasteFromWord',
              '-', 'Source',
            ]
        ],
        'width': 655,
        'height': 250,
        'toolbarCanCollapse': False,
        'linkShowTargetTab': False,
        'linkShowAdvancedTab': False,
    }
    , 'basic': {
        'toolbar': [
            [      'Bold', 'Italic',
              '-', 'Link', 'Unlink',
            ]
        ]
        , 'width': 600
        , 'height': 250
        , 'toolbarCanCollapse': False
        , 'toolbarLocation': 'bottom'
        , 'resize_enabled': False
        , 'removePlugins': 'elementspath'
        , 'forcePasteAsPlainText': True
  }
}
</code></pre>

<p>When setting up the <code>CKEditor</code> widget in your <code>Form</code> class you can pass a
<code>ckeditor_config</code> keyword argument to specify the config to use:</p>

<pre><code>class BlogPostForm(forms.Form):
    title = forms.CharField()

    # This field will render as a CKEditor with the 'simple_toolbar' config.
    subtitle = forms.CharField(
        widget=CKEditor(ckeditor_config='basic')
    )

    # This field will render as a CKEditor with the 'default' config.
    body = forms.CharField(
        widget=CKEditor()
    )
</code></pre>

<p>You cannot use the <code>HTMLField</code> shortcut if you want to specify a custom config
-- you <em>must</em> create a form.</p>

<h3 id="additional-configuration-options">Additional Configuration Options</h3>

<p>If you want to limit the formats available in the Format drop-down, add the following to the config definition:</p>

<pre><code>'format_tags': 'p;h3;h4', 
</code></pre>

<h3 id="embedded-content">Embedded content</h3>

<p>Links in your HTMLFields will be able to point to either a model's list view or a model instance's absolute url. To provide a url for a model, define a class method called absolute<em>list</em>url:</p>

<pre><code>@classmethod
def absolute_list_url(cls):
    return reverse('career_posting')
</code></pre>

<p>To provide a url for a model instance, define a method called get<em>absolute</em>url:</p>

<pre><code>@models.permalink
def get_absolute_url(self):
    return ('structure_page', None, {
        'slug': self.slug
    })
</code></pre>

<p>By default, links will be able to point to any model from any registered app. You can specify a list to limit the options by providing a <code>CKEDITOR_EMBED_CONTENT</code> setting like this:</p>

<p>CKEDITOR<em>EMBED</em>CONTENT = ['structure.page', 'services.service', 'services.technology', 'portfolio.portfolioitem']</p>

<p>This will limit the list to four items and hide models that don't have absolute urls like 'auth.group', etc.</p>

<h3 id="media-url">Media URL</h3>

<p>You can also customize the URL that django-ckeditor will look for the CKEditor
media at by adding <code>CKEDITOR_MEDIA_URL</code> to your <code>settings.py</code> file like this:</p>

<pre><code>CKEDITOR_MEDIA_URL = '/static/third-party/ckeditor'
</code></pre>

<p>The default value is <code>MEDIA_URL/ckeditor</code> which is why the setup instructions
tell you to symlink it into your <code>media/</code> directory.</p></div></div></div></div></body></html>